<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>圍棋練習題與比目法計分</title>
    <style>
        :root {
            --color-white: rgba(255, 255, 255, 1);
            --color-black: rgba(0, 0, 0, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-cream-100: rgba(255, 255, 253, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-slate-500: rgba(98, 108, 113, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-teal-700: rgba(26, 104, 115, 1);
            --color-bg-3: rgba(34, 197, 94, 0.08);
            --color-bg-4: rgba(239, 68, 68, 0.08);
            --color-background: var(--color-cream-50);
            --color-surface: var(--color-cream-100);
            --color-text: var(--color-slate-900);
            --color-text-secondary: var(--color-slate-500);
            --color-primary: var(--color-teal-500);
            --color-primary-hover: var(--color-teal-600);
            --color-primary-active: var(--color-teal-700);
            --color-error: #d32f2f;
            --color-success: #2e7d32;
            --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --font-size-base: 14px;
            --radius-base: 8px;
            --container-md: 900px;
            --space-8: 8px;
            --space-16: 16px;
            --space-24: 24px;
        }

        body {
            background: var(--color-background);
            color: var(--color-text);
            font-family: var(--font-family-base);
            margin: 0;
            padding: 20px 0;
        }

        .container {
            max-width: var(--container-md);
            margin: 0 auto;
            padding: var(--space-24);
        }

        .card {
            background: var(--color-surface);
            border-radius: var(--radius-base);
            box-shadow: 0 1px 3px rgba(0, 0, 0, .04);
            margin-bottom: var(--space-24);
            padding: var(--space-24);
        }

        h1 {
            color: var(--color-primary);
            margin-bottom: var(--space-24);
            text-align: center;
        }

        h2 {
            color: var(--color-primary);
            margin-bottom: var(--space-16);
            font-size: 20px;
        }

        h3 {
            color: var(--color-text);
            margin-bottom: var(--space-8);
            font-size: 16px;
        }

        p {
            line-height: 1.6;
            margin-bottom: var(--space-16);
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin: var(--space-16) 0;
        }

        canvas {
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .score-panel {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
            background: var(--color-bg-3);
            border-radius: var(--radius-base);
            padding: var(--space-16);
            margin: var(--space-16) 0;
        }

        .score-row {
            display: flex;
            align-items: center;
            gap: var(--space-16);
            flex-wrap: wrap;
        }

        .score-label {
            min-width: 80px;
            color: var(--color-primary);
            font-weight: 500;
        }

        .score-value {
            min-width: 30px;
            color: var(--color-text);
            font-weight: 600;
        }

        .winner-panel {
            border-radius: var(--radius-base);
            padding: var(--space-8) var(--space-16);
            background: var(--color-bg-4);
            color: var(--color-error);
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            margin-top: var(--space-8);
        }

        .btn {
            background: var(--color-primary);
            color: var(--color-white);
            font-size: 14px;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
            transition: background 0.2s;
        }

        .btn:hover {
            background: var(--color-primary-hover);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .options {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-8);
            margin-top: var(--space-8);
        }

        .option-btn {
            background: var(--color-surface);
            color: var(--color-primary);
            border: 2px solid var(--color-primary);
            padding: 8px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .option-btn:hover {
            background: rgba(33, 128, 141, 0.1);
        }

        .option-btn.selected {
            background: var(--color-primary);
            color: var(--color-white);
        }

        .feedback {
            margin-top: var(--space-8);
            padding: var(--space-8);
            border-radius: var(--radius-base);
            font-weight: 500;
        }

        .feedback.correct {
            background: rgba(46, 125, 50, 0.1);
            color: var(--color-success);
        }

        .feedback.incorrect {
            background: rgba(211, 47, 47, 0.1);
            color: var(--color-error);
        }

        .lesson {
            margin-bottom: var(--space-16);
        }

        .demo-board {
            margin: var(--space-16) 0;
        }

        ul {
            line-height: 1.8;
        }

        #liberty-problems {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-16);
            margin-top: var(--space-16);
        }

        #liberty-problems .card {
            margin-bottom: 0;
        }

        @media (max-width:600px) {
            .container {
                padding: var(--space-8);
            }

            canvas {
                max-width: 100%;
                height: auto !important;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>圍棋教學 - Go Tutorial (六課完整版)</h1>

        <!-- Lesson 1: Introduction -->
        <div class="card lesson">
            <h2>第一課：圍棋基礎 (Lesson 1: Go Basics)</h2>
            <p><strong>圍棋是什麼？</strong>圍棋是一種策略棋類遊戲，兩位玩家使用黑白棋子在棋盤上對弈。目標是控制比對手更多的地域。</p>
            <p><strong>What is Go?</strong> Go is a strategic board game where two players use black and white stones to
                compete on a board. The goal is to control more territory than your opponent.</p>
            <h3>棋盤與棋子 (Board &amp; Stones)</h3>
            <ul>
                <li>標準棋盤：19×19 線（361個交叉點）</li>
                <li>初學者可用9×9或13×13棋盤</li>
                <li>黑白雙方輪流在交叉點上落子</li>
                <li>黑方先行</li>
            </ul>
        </div>

        <!-- Lesson 2: Placing Stones -->
        <div class="card lesson">
            <h2>第二課：落子規則 (Lesson 2: Placing Stones)</h2>
            <p><strong>基本規則：</strong></p>
            <ul>
                <li>棋子放在線的交叉點上，不是方格內</li>
                <li>一旦落子就不能移動（除非被吃掉）</li>
                <li>黑白雙方輪流落子</li>
            </ul>
            <h3>示範：落子位置 (Demonstration)</h3>
            <div class="board-container">
                <canvas id="demo-placement" width="360" height="360"></canvas>
            </div>
            <p style="text-align:center; color: var(--color-text-secondary);">點擊棋盤任意交叉點落子</p>
        </div>

        <!-- Lesson 3: Liberties -->
        <div class="card lesson">
            <h2>第三課：氣與提子 (Lesson 3: Liberties &amp; Capture)</h2>
            <p><strong>氣（Liberties）：</strong>棋子周圍的空位稱為「氣」。當一組棋子沒有氣時會被吃掉。</p>
            <h3>互動示範：點擊棋子查看其「氣」</h3>
            <div class="board-container">
                <canvas id="demo-liberties" width="360" height="360"></canvas>
            </div>
            <p style="text-align:center; color: var(--color-text-secondary);">點擊棋子查看其周圍的「氣」（綠色圓圈）</p>

            <h3>練習題：數「氣」(Practice: Count Liberties)</h3>
            <p>點擊棋子查看其「氣」，然後選擇黑子正確的氣數。Click a stone to see its liberties, then select the correct count for black
                stones.</p>

            <div id="liberty-problems"></div>
            <h3>示範：提子 (Capture Demonstration)</h3>
            <p style="color: var(--color-text-secondary); margin-bottom: 10px;">
                <strong>觀看示範：</strong>白子被黑子包圍後會自動被提走。This is a demonstration - watch the sequence automatically.
            </p>
            <div class="board-container">
                <canvas id="demo-capture" width="360" height="360"></canvas>
            </div>
            <div style="text-align:center; margin-top: 10px;">
                <button class="btn" id="capture-demo-btn">播放示範 (Play Demo)</button>
            </div>
        </div>

        <!-- Lesson 4: Territory -->
        <div class="card lesson">
            <h2>第四課：地域計算 (Lesson 4: Territory)</h2>
            <p><strong>地域（Territory）：</strong>被你的棋子完全包圍的空點就是你的地域。</p>
            <p><strong>計分方式：</strong>地域數 + 棋盤上的子數 = 總分</p>
            <h3>示範：黑方地域（紅點標示）</h3>
            <div class="board-container">
                <canvas id="demo-territory" width="360" height="360"></canvas>
            </div>
            <p style="text-align:center; color: var(--color-text-secondary);">黑子圍住的空點用紅點標示，這些是黑方的地域</p>
        </div>

        <!-- Lesson 5: Komi Rule -->
        <div class="card lesson">
            <h2>第五課：貼目規則 (Lesson 5: Komi)</h2>
            <p><strong>貼目（Komi）：</strong>因為黑方先行有優勢，所以黑方需要貼目給白方。</p>
            <p><strong>標準規則：黑方貼目6.5目</strong></p>
            <p>計算公式：</p>
            <ul>
                <li>黑方分數 = 子數 + 地數 - 6.5</li>
                <li>白方分數 = 子數 + 地數</li>
            </ul>
        </div>

        <!-- Lesson 6: Forbidden Points and Eyes -->
        <div class="card lesson">
            <h2>第六課：禁著點及眼 (Lesson 6: Forbidden Points &amp; Eyes)</h2>

            <h3>禁著點（Forbidden Points）</h3>
            <p><strong>禁著點：</strong>在圍棋中，如果落子後該子沒有氣且不能吃掉對方的子，這個點就是「禁著點」，不能落子。</p>
            <p><strong>Forbidden Points:</strong> Points where placing a stone would result in immediate capture without
                capturing opponent stones.</p>

            <h3>圖示：禁著點範例 (Diagram Examples)</h3>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div>
                    <h4 style="text-align: center; margin-bottom: 10px;">範例1：自殺著 (Suicide Move)</h4>
                    <div class="board-container">
                        <canvas id="forbidden-example1" width="280" height="280"></canvas>
                    </div>
                    <p style="text-align:center; color: var(--color-text-secondary); font-size: 12px;">
                        紅點處為黑子的禁著點：黑子落此處會立即被吃掉<br />Red dot shows forbidden point: Black stone would be captured
                        immediately</p>
                </div>

                <div>
                    <h4 style="text-align: center; margin-bottom: 10px;">範例2：吃掉對方的子 (Capture)</h4>
                    <div class="board-container">
                        <canvas id="forbidden-example2" width="280" height="280"></canvas>
                    </div>
                    <p style="text-align:center; color: var(--color-text-secondary); font-size: 12px;">
                        紅點處雖為白子的禁著點，但可以吃掉對方黑子的子，所以白子可以落在此處。<br />Red dot shows forbidden point, however, black stone
                        could be captured, white stone can be placed in this point.</p>
                </div>
            </div>

            <div style="margin: 20px 0;">
                <h4 style="text-align: center; margin-bottom: 10px;">範例3：合法 vs 非法 (Legal vs Illegal)</h4>
                <div class="board-container">
                    <canvas id="forbidden-example3" width="360" height="360"></canvas>
                </div>
                <p style="text-align:center; color: var(--color-text-secondary); font-size: 12px;">紅點：禁著點（自殺）｜
                    綠點：合法落子（可吃掉對方）<br />Red dots: Forbidden (suicide) ｜ Green dot: Legal (can capture opponent)</p>
            </div>

            <h3>眼（Eyes）</h3>
            <p><strong>眼：</strong>被己方棋子完全包圍的空點稱為「眼」。擁有兩個或以上真眼的棋組永遠不會被吃掉。</p>
            <p><strong>Eyes:</strong> Empty points completely surrounded by your stones. Groups with two or more true
                eyes cannot be captured.</p>

            <h3>真眼 vs 假眼示範</h3>
            <div class="board-container">
                <canvas id="demo-eyes" width="360" height="360"></canvas>
            </div>
            <p style="text-align:center; color: var(--color-text-secondary);">左側：真眼（完全包圍）｜右側：假眼（有缺口）</p>

            <h3>重要性</h3>
            <ul>
                <li><strong>兩眼活棋：</strong>擁有兩個真眼的棋組永遠安全，對方無法吃掉</li>
                <li><strong>一眼或無眼：</strong>這樣的棋組容易被攻擊和吃掉</li>
                <li><strong>禁著點：</strong>通常出現在對方的眼位中，不能落子</li>
            </ul>
        </div>

        <!-- Exercise 3: Territory Counting -->
        <div class="card">
            <h2>練習題3：數地域 (Exercise 3: Count Territory)</h2>
            <p>請觀察下方棋盤，<strong>黑子圍住了多少個空點？</strong></p>
            <p>Look at the board below. <strong>How many empty points are enclosed by black stones?</strong></p>
            <div class="board-container">
                <canvas id="exercise3-board" width="280" height="280"></canvas>
            </div>
            <p style="text-align:center; color: var(--color-text-secondary); font-size: 12px;">提示：答案會用紅點標示在棋盤上</p>
            <div class="options" id="exercise3-options"></div>
            <div class="feedback" id="exercise3-feedback"></div>
        </div>

        <!-- Free Practice Area -->
        <div class="card">
            <h2>自由練習區 &amp; 比目法計分 (Free Practice &amp; Scoring)</h2>
            <p>請在5×5棋盤上自由落子，系統會即時計算雙方的子數、地數、被吃的子，並顯示最終得分。</p>
            <p>Play freely on the 5×5 board. The system calculates stones, territory, captures, and final scores in
                real-time.</p>
            <div class="board-container">
                <canvas id="practice-board" width="400" height="400"></canvas>
            </div>
            <div>
                <button class="btn" id="reset-btn">重置棋盤 (Reset)</button>
                <button class="btn" id="undo-btn">悔棋 (Undo)</button>
                <span id="turn-indicator" style="margin-left: 10px; font-weight: 600;">當前：黑方</span>
            </div>
            <div id="warning-message"
                style="display:none; margin-top: 10px; padding: 12px; background: rgba(211,47,47,0.15); color: var(--color-error); border-radius: 8px; font-weight: 600; font-size: 15px; text-align: center; border: 2px solid var(--color-error);">
            </div>
            <div class="score-panel" id="score-panel">
                <!-- Scores will be dynamically injected here -->
            </div>
        </div>

    </div>
    <script>
        // ========== UTILITY FUNCTIONS ==========
        function drawBoard(canvas, size, board, showGrid = true) {
            const ctx = canvas.getContext('2d');
            const padding = 30;
            const gridSize = (canvas.width - 2 * padding) / (size - 1);

            // Clear canvas
            ctx.fillStyle = '#deb887';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid lines
            if (showGrid) {
                ctx.strokeStyle = '#8b7355';
                ctx.lineWidth = 1;
                for (let i = 0; i < size; i++) {
                    // Vertical lines
                    ctx.beginPath();
                    ctx.moveTo(padding + i * gridSize, padding);
                    ctx.lineTo(padding + i * gridSize, padding + (size - 1) * gridSize);
                    ctx.stroke();
                    // Horizontal lines
                    ctx.beginPath();
                    ctx.moveTo(padding, padding + i * gridSize);
                    ctx.lineTo(padding + (size - 1) * gridSize, padding + i * gridSize);
                    ctx.stroke();
                }
            }

            // Draw stones
            if (board) {
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const stone = board[y][x];
                        if (stone) {
                            const cx = padding + x * gridSize;
                            const cy = padding + y * gridSize;
                            ctx.beginPath();
                            ctx.arc(cx, cy, gridSize * 0.4, 0, Math.PI * 2);
                            if (stone === 'B') {
                                ctx.fillStyle = '#000';
                                ctx.fill();
                            } else if (stone === 'W') {
                                ctx.fillStyle = '#fff';
                                ctx.fill();
                                ctx.strokeStyle = '#333';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                    }
                }
            }

            return { padding, gridSize };
        }

        function getBoardCoords(canvas, size, evt) {
            const rect = canvas.getBoundingClientRect();
            const padding = 30;
            const gridSize = (canvas.width - 2 * padding) / (size - 1);
            const x = evt.clientX - rect.left;
            const y = evt.clientY - rect.top;
            const gx = Math.round((x - padding) / gridSize);
            const gy = Math.round((y - padding) / gridSize);
            if (gx >= 0 && gx < size && gy >= 0 && gy < size) {
                return { x: gx, y: gy };
            }
            return null;
        }

        // ========== LESSON 2: PLACEMENT DEMO ==========
        const demoPlacement = document.getElementById('demo-placement');
        const placementSize = 9;
        let placementBoard = Array(placementSize).fill(null).map(() => Array(placementSize).fill(null));
        let placementTurn = 'B';

        function redrawPlacement() {
            drawBoard(demoPlacement, placementSize, placementBoard);
        }

        demoPlacement.addEventListener('click', (e) => {
            const coords = getBoardCoords(demoPlacement, placementSize, e);
            if (coords && !placementBoard[coords.y][coords.x]) {
                placementBoard[coords.y][coords.x] = placementTurn;
                placementTurn = placementTurn === 'B' ? 'W' : 'B';
                redrawPlacement();
            }
        });

        redrawPlacement();

        // ========== LESSON 3: LIBERTIES INTERACTIVE DEMO ==========
        const demoLiberties = document.getElementById('demo-liberties');
        const libertiesSize = 5;
        let libertiesBoard = Array(libertiesSize).fill(null).map(() => Array(libertiesSize).fill(null));
        let selectedStone = null;

        // Setup: Various stones to demonstrate liberties
        libertiesBoard[0][0] = 'B'; // Corner stone - 2 liberties
        libertiesBoard[0][2] = 'W'; // Edge stone - 3 liberties  
        libertiesBoard[2][2] = 'B'; // Center stone - 4 liberties
        libertiesBoard[3][3] = 'W';
        libertiesBoard[3][4] = 'B';

        function drawLiberties() {
            const { padding, gridSize } = drawBoard(demoLiberties, libertiesSize, libertiesBoard);
            const ctx = demoLiberties.getContext('2d');

            // If a stone is selected, show its liberties
            if (selectedStone) {
                const { x, y } = selectedStone;
                const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];

                ctx.fillStyle = 'rgba(46, 125, 50, 0.5)';
                for (let [dx, dy] of dirs) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < libertiesSize && ny >= 0 && ny < libertiesSize && !libertiesBoard[ny][nx]) {
                        const cx = padding + nx * gridSize;
                        const cy = padding + ny * gridSize;
                        ctx.beginPath();
                        ctx.arc(cx, cy, gridSize * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        demoLiberties.addEventListener('click', (e) => {
            const coords = getBoardCoords(demoLiberties, libertiesSize, e);
            if (coords && libertiesBoard[coords.y][coords.x]) {
                selectedStone = coords;
                drawLiberties();
            } else {
                selectedStone = null;
                drawLiberties();
            }
        });

        drawLiberties();

        // ========== LESSON 3: LIBERTY PRACTICE PROBLEMS ==========
        const libertyProblems = [
            // Problem 1: Corner stone - 2 liberties
            {
                board: [[null, null, 'B'], [null, null, null], [null, null, null]],
                size: 3,
                stonePos: { x: 2, y: 0 },
                answer: 2,
                description: "角落單子 (Corner stone)"
            },
            // Problem 2: Edge stone - 3 liberties
            {
                board: [[null, null, null], [null, 'B', null], [null, null, null]],
                size: 3,
                stonePos: { x: 1, y: 1 },
                answer: 4,
                description: "中央單子 (Center stone)"
            },
            // Problem 3: Two connected stones in corner
            {
                board: [['B', 'B', null, null], [null, null, null, null], [null, null, null, null], [null, null, null, null]],
                size: 4,
                stonePos: { x: 0, y: 0 },
                answer: 3,
                description: "角落兩子連接 (Two stones connected in corner)"
            },
            // Problem 4: Three stones in a row (edge)
            {
                board: [[null, null, null, null, null], ['B', 'B', 'B', null, null], [null, null, null, null, null], [null, null, null, null, null], [null, null, null, null, null]],
                size: 5,
                stonePos: { x: 1, y: 1 },
                answer: 7,
                description: "邊上三子一線 (Three stones in a row on edge)"
            },
            // Problem 5: L-shape group
            {
                board: [[null, null, null, null], [null, 'B', 'B', null], [null, 'B', null, null], [null, null, null, null]],
                size: 4,
                stonePos: { x: 1, y: 1 },
                answer: 7,
                description: "L形棋組 (L-shaped group)"
            },
            // Problem 6: Surrounded stone with one liberty
            {
                board: [[null, null, 'W', null, null], [null, 'W', 'B', 'W', null], ['W', 'B', null, 'B', 'W'], [null, 'W', 'B', 'W', null], [null, null, 'W', null, null]],
                size: 5,
                stonePos: { x: 2, y: 2 },
                answer: 1,
                description: "被圍的黑子 (Surrounded black stone)"
            },
            // Problem 7: Four stones in square
            {
                board: [[null, null, null, null, null], [null, 'B', 'B', null, null], [null, 'B', 'B', null, null], [null, null, null, null, null], [null, null, null, null, null]],
                size: 5,
                stonePos: { x: 1, y: 1 },
                answer: 8,
                description: "四子方形 (Four stones in square)"
            },
            // Problem 8: Mixed colors - white stone near black
            {
                board: [[null, null, null, null], [null, 'W', null, null], [null, 'B', 'W', null], [null, null, null, null]],
                size: 4,
                stonePos: { x: 1, y: 2 },
                answer: 2,
                description: "黑子旁有兩白子 (Black stone near two white stones)"
            },
            // Problem 9: Long chain on edge
            {
                board: [[null, null, null, null, null, null], ['B', 'B', 'B', 'B', null, null], [null, null, null, null, null, null], [null, null, null, null, null, null], [null, null, null, null, null, null], [null, null, null, null, null, null]],
                size: 6,
                stonePos: { x: 2, y: 1 },
                answer: 9,
                description: "邊上長鏈 (Long chain on edge)"
            },
            // Problem 10: Complex group in center
            {
                board: [[null, null, null, null, null, null], [null, null, 'B', null, null, null], [null, 'B', 'B', 'B', null, null], [null, null, 'B', null, null, null], [null, null, null, null, null, null], [null, null, null, null, null, null]],
                size: 6,
                stonePos: { x: 2, y: 2 },
                answer: 8,
                description: "中央複雜棋組 (Complex group in center)"
            }
        ];

        function createLibertyProblem(problem, index) {
            const container = document.createElement('div');
            container.className = 'card';
            container.style.marginBottom = '20px';

            container.innerHTML = `
    <h4>練習 ${index + 1}: ${problem.description}</h4>
    <p style="color: var(--color-text-secondary); font-size: 13px;">點擊棋子查看其氣，然後選擇正確數量</p>
    <div class="board-container">
      <canvas id="liberty-problem-${index}" width="240" height="240"></canvas>
    </div>
    <div class="options" id="liberty-options-${index}"></div>
    <div class="feedback" id="liberty-feedback-${index}"></div>
  `;

            document.getElementById('liberty-problems').appendChild(container);

            // Setup canvas
            const canvas = document.getElementById(`liberty-problem-${index}`);
            let selectedStone = null;
            let answered = false;

            function drawProblem() {
                const { padding, gridSize } = drawBoard(canvas, problem.size, problem.board);
                const ctx = canvas.getContext('2d');

                // Show liberties if stone is selected
                if (selectedStone) {
                    const libertyPositions = [];
                    const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];
                    const visited = new Set();
                    const color = problem.board[selectedStone.y][selectedStone.x];

                    // Find all stones in the group
                    const group = [];
                    const todo = [selectedStone];
                    visited.add(`${selectedStone.x},${selectedStone.y}`);

                    while (todo.length > 0) {
                        const current = todo.pop();
                        group.push(current);

                        for (let [dx, dy] of dirs) {
                            const nx = current.x + dx;
                            const ny = current.y + dy;
                            const key = `${nx},${ny}`;

                            if (nx >= 0 && nx < problem.size && ny >= 0 && ny < problem.size && !visited.has(key)) {
                                if (problem.board[ny][nx] === color) {
                                    visited.add(key);
                                    todo.push({ x: nx, y: ny });
                                }
                            }
                        }
                    }

                    // Find liberties for the entire group
                    const libertySet = new Set();
                    for (let stone of group) {
                        for (let [dx, dy] of dirs) {
                            const nx = stone.x + dx;
                            const ny = stone.y + dy;
                            if (nx >= 0 && nx < problem.size && ny >= 0 && ny < problem.size && !problem.board[ny][nx]) {
                                libertySet.add(`${nx},${ny}`);
                            }
                        }
                    }

                    // Draw liberties
                    ctx.fillStyle = 'rgba(46, 125, 50, 0.6)';
                    for (let key of libertySet) {
                        const [x, y] = key.split(',').map(Number);
                        const cx = padding + x * gridSize;
                        const cy = padding + y * gridSize;
                        ctx.beginPath();
                        ctx.arc(cx, cy, gridSize * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Show count
                    ctx.fillStyle = 'rgba(46, 125, 50, 0.9)';
                    ctx.font = 'bold 16px ' + getComputedStyle(document.body).fontFamily;
                    ctx.fillText(`氣數: ${libertySet.size}`, canvas.width / 2, 20);
                    ctx.textAlign = 'center';
                }
            }

            canvas.addEventListener('click', (e) => {
                if (answered) return;

                const coords = getBoardCoords(canvas, problem.size, e);
                if (coords && problem.board[coords.y][coords.x]) {
                    selectedStone = coords;
                    drawProblem();
                }
            });

            // Create answer options
            const optionsDiv = document.getElementById(`liberty-options-${index}`);
            //            const options = [problem.answer - 1, problem.answer, problem.answer + 1, problem.answer + 2].filter(n => n > 0);
            //自加開始20251123.0129
            // 所有可能的偏移模式（以答案為 0）
            const offsetPatterns = [
                [-3, -2, -1, 0],
                [-2, -1, 0, 1],
                [-1, 0, 1, 2],
                [0, 1, 2, 3],
                [-3, -1, 0, 2],   // 你可以自行再加其他 pattern
                [-4, -1, 0, 3],
            ];

            // 隨機選一個 pattern
            const pattern = offsetPatterns[
                Math.floor(Math.random() * offsetPatterns.length)
            ];

            // 套用到答案上，並確保是正整數
            let options = pattern
                .map(d => problem.answer + d)
                .filter(n => Number.isInteger(n) && n > 0);
            //自加完結20251123.0129


            const uniqueOptions = [...new Set(options)].sort((a, b) => a - b).slice(0, 4);

            uniqueOptions.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.textContent = `${opt} 氣`;
                btn.addEventListener('click', () => {
                    if (answered) return;

                    document.querySelectorAll(`#liberty-options-${index} .option-btn`).forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');

                    const feedback = document.getElementById(`liberty-feedback-${index}`);
                    feedback.className = 'feedback';

                    if (opt === problem.answer) {
                        feedback.textContent = `✓ 正確！這組棋子有 ${problem.answer} 氣。`;
                        feedback.classList.add('correct');
                        answered = true;
                    } else {
                        feedback.textContent = `✗ 不正確。請再點擊棋子仔細數一數。`;
                        feedback.classList.add('incorrect');
                    }
                });
                optionsDiv.appendChild(btn);
            });

            drawProblem();
        }

        // Create all 10 problems
        libertyProblems.forEach((problem, index) => {
            createLibertyProblem(problem, index);
        });

        // ========== LESSON 3: CAPTURE DEMO ==========
        const demoCapture = document.getElementById('demo-capture');
        const captureSize = 9;
        let captureBoard = Array(captureSize).fill(null).map(() => Array(captureSize).fill(null));
        let captureDemoStep = 0;

        // Setup initial position
        function resetCaptureDemo() {
            captureBoard = Array(captureSize).fill(null).map(() => Array(captureSize).fill(null));
            captureBoard[4][4] = 'W';
            captureBoard[3][4] = 'B';
            captureBoard[5][4] = 'B';
            captureBoard[4][3] = 'B';
            captureDemoStep = 0;
            drawBoard(demoCapture, captureSize, captureBoard);
        }

        function playCaptureDemo() {
            if (captureDemoStep > 0) {
                resetCaptureDemo();
                return;
            }

            captureDemoStep = 1;

            // Animate the final move and capture
            setTimeout(() => {
                captureBoard[4][5] = 'B';
                drawBoard(demoCapture, captureSize, captureBoard);

                // Flash and remove captured stone
                setTimeout(() => {
                    let flashes = 0;
                    const flashInterval = setInterval(() => {
                        if (flashes % 2 === 0) {
                            captureBoard[4][4] = null;
                        } else {
                            captureBoard[4][4] = 'W';
                        }
                        drawBoard(demoCapture, captureSize, captureBoard);
                        flashes++;
                        if (flashes >= 6) {
                            clearInterval(flashInterval);
                            captureBoard[4][4] = null;
                            drawBoard(demoCapture, captureSize, captureBoard);
                            captureDemoStep = 2;
                        }
                    }, 200);
                }, 500);
            }, 300);
        }

        document.getElementById('capture-demo-btn').addEventListener('click', playCaptureDemo);
        resetCaptureDemo();

        // ========== LESSON 4: TERRITORY DEMO ==========
        const demoTerritory = document.getElementById('demo-territory');
        const territorySize = 9;
        let territoryBoard = Array(territorySize).fill(null).map(() => Array(territorySize).fill(null));

        // Setup: Black stones forming a territory
        for (let x = 2; x <= 6; x++) {
            territoryBoard[2][x] = 'B';
            territoryBoard[6][x] = 'B';
        }
        for (let y = 3; y <= 5; y++) {
            territoryBoard[y][2] = 'B';
            territoryBoard[y][6] = 'B';
        }
        // Inner area (3,3) to (5,5) = 9 points of territory

        const { padding: tPadding, gridSize: tGridSize } = drawBoard(demoTerritory, territorySize, territoryBoard);

        // Mark territory with red dots
        const tCtx = demoTerritory.getContext('2d');
        tCtx.fillStyle = 'rgba(255, 0, 0, 0.7)';
        for (let y = 3; y <= 5; y++) {
            for (let x = 3; x <= 5; x++) {
                if (!territoryBoard[y][x]) {
                    const cx = tPadding + x * tGridSize;
                    const cy = tPadding + y * tGridSize;
                    tCtx.beginPath();
                    tCtx.arc(cx, cy, tGridSize * 0.15, 0, Math.PI * 2);
                    tCtx.fill();
                }
            }
        }

        // ========== LESSON 6: FORBIDDEN POINTS DIAGRAMS ==========

        // Example 1: Suicide move
        const forbidden1Canvas = document.getElementById('forbidden-example1');
        const forbidden1Size = 5;
        let forbidden1Board = Array(forbidden1Size).fill(null).map(() => Array(forbidden1Size).fill(null));

        // White stones surrounding a point
        forbidden1Board[1][2] = 'W';
        forbidden1Board[2][1] = 'W';
        forbidden1Board[2][3] = 'W';
        forbidden1Board[3][2] = 'W';
        // Point (2,2) is forbidden for black - would be captured immediately

        const { padding: f1p, gridSize: f1g } = drawBoard(forbidden1Canvas, forbidden1Size, forbidden1Board);
        const f1ctx = forbidden1Canvas.getContext('2d');
        f1ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
        f1ctx.beginPath();
        f1ctx.arc(f1p + 2 * f1g, f1p + 2 * f1g, f1g * 0.25, 0, Math.PI * 2);
        f1ctx.fill();

        // Example 2: Filling own eye
        const forbidden2Canvas = document.getElementById('forbidden-example2');
        const forbidden2Size = 5;
        let forbidden2Board = Array(forbidden2Size).fill(null).map(() => Array(forbidden2Size).fill(null));

        forbidden2Board[1][2] = 'B';
        forbidden2Board[2][1] = 'B';
        forbidden2Board[2][3] = 'B';
        forbidden2Board[3][2] = 'B';
        // Surrounded by white
        forbidden2Board[0][2] = 'W';
        forbidden2Board[1][1] = 'W';
        forbidden2Board[1][3] = 'W';
        forbidden2Board[2][0] = 'W';
        forbidden2Board[2][4] = 'W';
        forbidden2Board[3][1] = 'W';
        forbidden2Board[3][1] = 'W';
        forbidden2Board[3][3] = 'W';
        forbidden2Board[4][2] = 'W';
        // Point (2,2) is the eye - filling it would be suicide

        const { padding: f2p, gridSize: f2g } = drawBoard(forbidden2Canvas, forbidden2Size, forbidden2Board);
        const f2ctx = forbidden2Canvas.getContext('2d');
        f2ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
        f2ctx.beginPath();
        f2ctx.arc(f2p + 2 * f2g, f2p + 2 * f2g, f2g * 0.25, 0, Math.PI * 2);
        f2ctx.fill();

        // Example 3: Legal vs Illegal
        const forbidden3Canvas = document.getElementById('forbidden-example3');
        const forbidden3Size = 9;
        let forbidden3Board = Array(forbidden3Size).fill(null).map(() => Array(forbidden3Size).fill(null));

        // Setup: White group with one liberty, and a suicide point
        forbidden3Board[3][3] = 'W';
        forbidden3Board[3][4] = 'W';
        forbidden3Board[4][3] = 'W';
        forbidden3Board[4][4] = 'W';
        forbidden3Board[2][3] = 'B';
        forbidden3Board[2][4] = 'B';
        forbidden3Board[3][2] = 'B';
        forbidden3Board[4][2] = 'B';
        forbidden3Board[5][3] = 'B';
        forbidden3Board[5][4] = 'B';
        forbidden3Board[3][5] = 'B';
        // (4,5) is the last liberty of white - black CAN play here (captures white)
        // (6,6) surrounded by black - black CANNOT play here (suicide)
        forbidden3Board[5][6] = 'B';
        forbidden3Board[6][5] = 'B';
        forbidden3Board[7][6] = 'B';
        forbidden3Board[6][7] = 'B';

        const { padding: f3p, gridSize: f3g } = drawBoard(forbidden3Canvas, forbidden3Size, forbidden3Board);
        const f3ctx = forbidden3Canvas.getContext('2d');

        // Mark legal move (green)
        f3ctx.fillStyle = 'rgba(46, 125, 50, 0.7)';
        f3ctx.beginPath();
        f3ctx.arc(f3p + 5 * f3g, f3p + 4 * f3g, f3g * 0.25, 0, Math.PI * 2);
        f3ctx.fill();

        // Mark illegal move (red)
        f3ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
        f3ctx.beginPath();
        f3ctx.arc(f3p + 6 * f3g, f3p + 6 * f3g, f3g * 0.25, 0, Math.PI * 2);
        f3ctx.fill();

        // ========== LESSON 6: EYES DEMO ==========
        const demoEyes = document.getElementById('demo-eyes');
        const eyesSize = 9;
        let eyesBoard = Array(eyesSize).fill(null).map(() => Array(eyesSize).fill(null));

        // Left side: True eye example (black group with 2 true eyes)
        for (let x = 1; x <= 4; x++) {
            eyesBoard[2][x] = 'B';
            eyesBoard[5][x] = 'B';
        }
        for (let y = 2; y <= 5; y++) {
            eyesBoard[y][1] = 'B';
            eyesBoard[y][4] = 'B';
        }
        eyesBoard[3][2] = 'B';
        eyesBoard[3][3] = 'B';
        // Empty points at (2,3), (2,4), (4,3), (4,4) are true eyes

        // Right side: False eye example (incomplete enclosure)
        for (let x = 5; x <= 7; x++) {
            eyesBoard[2][x] = 'W';
            eyesBoard[5][x] = 'W';
        }
        for (let y = 3; y <= 4; y++) {
            eyesBoard[y][5] = 'W';
        }
        // Missing stone at (4,7) creates a false eye

        drawBoard(demoEyes, eyesSize, eyesBoard);

        // ========== LESSON 6: GAME DEMO (REMOVED) ==========
        const demoGame = document.getElementById('demo-game');
        const gameSize = 9;
        const gameSteps = [
            { x: 6, y: 6, c: 'B' }, { x: 2, y: 2, c: 'W' }, { x: 6, y: 2, c: 'B' }, { x: 2, y: 6, c: 'W' },
            { x: 4, y: 4, c: 'B' }, { x: 3, y: 4, c: 'W' }, { x: 5, y: 4, c: 'B' }, { x: 4, y: 3, c: 'W' },
            { x: 4, y: 5, c: 'B' }
        ];
        let gameBoard = Array(gameSize).fill(null).map(() => Array(gameSize).fill(null));
        let gameStep = 0;

        function updateGame() {
            drawBoard(demoGame, gameSize, gameBoard);
            document.getElementById('game-info').textContent = `步數: ${gameStep}/${gameSteps.length}`;
        }

        // Game demo removed - replaced with eyes explanation

        // ========== EXERCISE 3: TERRITORY COUNTING ==========
        const exercise3Canvas = document.getElementById('exercise3-board');
        const ex3_size = 7;
        let ex3_board = Array(ex3_size).fill(null).map(() => Array(ex3_size).fill(null));

        // Create a clear example with exactly 2 enclosed points
        // Black stones form a small enclosure at center
        // Pattern: vertical line of black stones with 2 empty points inside
        ex3_board[2][3] = 'B';
        ex3_board[3][2] = 'B';
        ex3_board[3][3] = null; // Empty point 1
        ex3_board[3][4] = 'B';
        ex3_board[4][2] = 'B';
        ex3_board[4][3] = null; // Empty point 2
        ex3_board[4][4] = 'B';
        ex3_board[5][3] = 'B';

        const { padding: ex3Padding, gridSize: ex3GridSize } = drawBoard(exercise3Canvas, ex3_size, ex3_board);

        // Mark the 2 answer points with red dots when answer is selected
        let ex3_showAnswer = false;

        function drawEx3Answer() {
            drawBoard(exercise3Canvas, ex3_size, ex3_board);
            if (ex3_showAnswer) {
                const ctx = exercise3Canvas.getContext('2d');
                const { padding, gridSize } = { padding: ex3Padding, gridSize: ex3GridSize };
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';

                // Mark the 2 enclosed points
                const answerPoints = [[3, 3], [3, 4]];
                for (let [x, y] of answerPoints) {
                    const cx = padding + x * gridSize;
                    const cy = padding + y * gridSize;
                    ctx.beginPath();
                    ctx.arc(cx, cy, gridSize * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Options
        const ex3_options = [1, 2, 3, 4];
        const ex3_answer = 2;
        const options_div = document.getElementById('exercise3-options');
        ex3_options.forEach(opt => {
            let btn = document.createElement('button');
            btn.className = 'option-btn';
            btn.textContent = opt + ' 個';
            btn.addEventListener('click', () => {
                document.querySelectorAll('.option-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                const feedback = document.getElementById('exercise3-feedback');
                feedback.className = 'feedback';
                if (opt === ex3_answer) {
                    feedback.textContent = '✓ 正確！黑子圍住2個空點（已用紅點標示）。(Correct! Black encloses 2 empty points marked with red dots.)';
                    feedback.classList.add('correct');
                    ex3_showAnswer = true;
                    drawEx3Answer();
                } else {
                    feedback.textContent = '✗ 錯誤，請再仔細觀察棋盤。(Incorrect, please look more carefully.)';
                    feedback.classList.add('incorrect');
                    ex3_showAnswer = false;
                    drawEx3Answer();
                }
            });
            options_div.appendChild(btn);
        });

        // ========== PRACTICE AREA ==========
        const practiceCanvas = document.getElementById('practice-board');
        //        const practice_size = 9;
        const practice_size = 5;
        let board = []; // 2D array: 9x9
        let turn = 'B'; // 'B'黑, 'W'白
        let captured = { B: 0, W: 0 };
        let moveHistory = []; // Stack for undo: [{board, turn, captured}]
        let moveNumbers = []; // 2D array tracking move numbers
        let moveCounter = 0;
        let markedPoints = new Set(); // Forbidden points (marked with red dots)

        function newBoard() {
            board = [];
            moveNumbers = [];
            for (let y = 0; y < practice_size; y++) {
                let row = [];
                let numRow = [];
                for (let x = 0; x < practice_size; x++) {
                    row.push(null);
                    numRow.push(0);
                }
                board.push(row);
                moveNumbers.push(numRow);
            }
            captured = { B: 0, W: 0 };
            turn = 'B';
            moveHistory = [];
            moveCounter = 0;
            markedPoints.clear();
            drawPracticeBoard();
            calcScore();
        }

        function drawPracticeBoard() {
            const { padding, gridSize } = drawBoard(practiceCanvas, practice_size, board);
            const ctx = practiceCanvas.getContext('2d');

            // Draw move numbers on stones
            ctx.font = `${Math.floor(gridSize * 0.4)}px ${getComputedStyle(document.body).fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let y = 0; y < practice_size; y++) {
                for (let x = 0; x < practice_size; x++) {
                    if (board[y][x] && moveNumbers[y][x] > 0) {
                        const cx = padding + x * gridSize;
                        const cy = padding + y * gridSize;

                        // Choose text color based on stone color
                        ctx.fillStyle = board[y][x] === 'B' ? '#fff' : '#000';
                        ctx.fillText(moveNumbers[y][x].toString(), cx, cy);
                    }
                }
            }

            // Draw marked points (red dots) for forbidden points
            ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
            for (let key of markedPoints) {
                const [x, y] = key.split(',').map(Number);
                const cx = padding + x * gridSize;
                const cy = padding + y * gridSize;
                ctx.beginPath();
                ctx.arc(cx, cy, gridSize * 0.15, 0, Math.PI * 2);
                ctx.fill();
            }

            updateTurnIndicator();
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turn-indicator');
            if (turn === 'B') {
                indicator.textContent = '當前：黑方 (Current: Black)';
                indicator.style.color = '#000';
            } else {
                indicator.textContent = '當前：白方 (Current: White)';
                indicator.style.color = '#666';
            }
        }

        // Check if a move is legal (not a suicide move)
        function isLegalMove(x, y, color) {
            // Temporarily place the stone
            const tempBoard = board.map(row => [...row]);
            tempBoard[y][x] = color;

            // Check if this move captures any opponent stones
            const opponent = color === 'B' ? 'W' : 'B';
            const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];

            for (let [dx, dy] of dirs) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < practice_size && ny >= 0 && ny < practice_size && tempBoard[ny][nx] === opponent) {
                    // Check if this opponent group would have no liberties
                    const oppGroup = findGroupOnBoard(nx, ny, opponent, tempBoard);
                    if (oppGroup.libs === 0) {
                        // This move captures opponent stones, so it's legal
                        return true;
                    }
                }
            }

            // Check if the placed stone itself would have liberties
            const myGroup = findGroupOnBoard(x, y, color, tempBoard);
            return myGroup.libs > 0;
        }

        function findGroupOnBoard(x, y, color, boardState) {
            let stones = [], libs = 0;
            let visited = new Set();
            let todo = [[x, y]];

            while (todo.length > 0) {
                let [cx, cy] = todo.pop();
                let key = cx + ',' + cy;
                if (visited.has(key)) continue;
                visited.add(key);
                if (boardState[cy][cx] != color) continue;
                stones.push([cx, cy]);

                for (let [nx, ny] of neighbours(cx, cy)) {
                    if (boardState[ny][nx] == null) {
                        libs++;
                    } else if (boardState[ny][nx] == color && !visited.has(nx + ',' + ny)) {
                        todo.push([nx, ny]);
                    }
                }
            }
            return { stones, libs };
        }

        //        practiceCanvas.addEventListener('click', (e) => {
        //            const coords = getBoardCoords(practiceCanvas, practice_size, e);
        //            if (!coords) return;
        practiceCanvas.addEventListener('click', (e) => {
            const pt = getCanvasPoint(practiceCanvas, e);  // 算好 canvas 內座標 [web:41][web:42]
            const coords = getBoardCoordsFromPoint(practiceCanvas, practice_size, pt);

            const warningMsg = document.getElementById('warning-message');

            if (coords && !board[coords.y][coords.x]) {
                // Check if this is a legal move (not suicide)
                if (!isLegalMove(coords.x, coords.y, turn)) {
                    warningMsg.textContent = '禁著點！無法在此位置落子。(Forbidden point! Cannot place stone here.)';
                    warningMsg.style.display = 'block';
                    setTimeout(() => {
                        warningMsg.style.display = 'none';
                    }, 3000);
                    return;
                }

                // Save state for undo
                moveHistory.push({
                    board: board.map(row => [...row]),
                    moveNumbers: moveNumbers.map(row => [...row]),
                    turn: turn,
                    captured: { ...captured },
                    moveCounter: moveCounter
                });

                // Place stone
                board[coords.y][coords.x] = turn;
                moveCounter++;
                moveNumbers[coords.y][coords.x] = moveCounter;

                let opp = turn === 'B' ? 'W' : 'B';
                let removed = removeDeadStones(opp);
                captured[turn] += removed;
                turn = opp;

                warningMsg.style.display = 'none';
                drawPracticeBoard();
                calcScore();
            }
        });
        function neighbours(x, y) {
            const ds = [[1, 0], [0, 1], [-1, 0], [0, -1]];
            return ds.map(([dx, dy]) => [x + dx, y + dy])
                .filter(([nx, ny]) => nx >= 0 && nx < practice_size && ny >= 0 && ny < practice_size);
        }
        function findGroup(x, y, color, visited) {
            let stones = [], libs = 0;
            let todo = [[x, y]];
            while (todo.length > 0) {
                let [cx, cy] = todo.pop();
                let key = cx + ',' + cy;
                if (visited.has(key)) continue;
                visited.add(key);
                if (board[cy][cx] != color) continue;
                stones.push([cx, cy]);
                for (let [nx, ny] of neighbours(cx, cy)) {
                    if (board[ny][nx] == null) libs++;
                    else if (board[ny][nx] == color) todo.push([nx, ny]);
                }
            }
            return { stones, libs };
        }
        function removeDeadStones(color) {
            let removed = 0;
            let visited = new Set();
            for (let y = 0; y < practice_size; y++) {
                for (let x = 0; x < practice_size; x++) {
                    if (board[y][x] == color && !visited.has(x + ',' + y)) {
                        let group = findGroup(x, y, color, visited);
                        if (group.libs == 0) { // Dead
                            for (let [gx, gy] of group.stones) {
                                board[gy][gx] = null;
                                moveNumbers[gy][gx] = 0;
                                removed++;
                            }
                        }
                    }
                }
            }
            return removed;
        }
        function countStones(color) {
            let cnt = 0;
            for (let y = 0; y < practice_size; y++) {
                for (let x = 0; x < practice_size; x++) {
                    if (board[y][x] == color) cnt++;
                }
            }
            return cnt;
        }
        function countTerritory(color) {
            let territory = 0;
            let visited = new Set();
            for (let y = 0; y < practice_size; y++) {
                for (let x = 0; x < practice_size; x++) {
                    if (board[y][x] == null && !visited.has(x + ',' + y)) {
                        let { empty, owner } = scanTerritory(x, y, visited);
                        if (owner == color) territory += empty.length;
                    }
                }
            }
            return territory;
        }
        // BFS to scan empty points, return {empty, owner}
        function scanTerritory(x, y, visited) {
            let empty = [[x, y]];
            let touching = new Set();
            let todo = [[x, y]];
            visited.add(x + ',' + y);
            while (todo.length > 0) {
                let [cx, cy] = todo.pop();
                for (let [nx, ny] of neighbours(cx, cy)) {
                    if (nx < 0 || nx >= practice_size || ny < 0 || ny >= practice_size) continue;
                    if (board[ny][nx] == null && !visited.has(nx + ',' + ny)) {
                        visited.add(nx + ',' + ny);
                        empty.push([nx, ny]);
                        todo.push([nx, ny]);
                    } else if (board[ny][nx] != null) {
                        touching.add(board[ny][nx]);
                    }
                }
            }
            let owner = null;
            if (touching.size == 1) owner = [...touching][0]; // Only one color touches
            return { empty, owner };
        }
        function calcScore() {
            const komi = 6.5;
            let black_stones = countStones('B');
            let white_stones = countStones('W');
            let black_territory = countTerritory('B');
            let white_territory = countTerritory('W');
            let black_captured = captured['W'];
            let white_captured = captured['B'];
            let black_total = black_stones + black_territory - komi;
            let white_total = white_stones + white_territory;
            let margin = Math.abs(white_total - black_total).toFixed(1);
            let winner = white_total > black_total ? '白方獲勝 (White Wins)' :
                (black_total > white_total ? '黑方獲勝 (Black Wins)' : '平局 (Draw)');

            document.getElementById('score-panel').innerHTML = `
    <div class='score-row'>
      <span class='score-label'>黑方子數:</span>
      <span class='score-value'>${black_stones}</span>
      <span class='score-label'>地數:</span>
      <span class='score-value'>${black_territory}</span>
      <span class='score-label'>被吃:</span>
      <span class='score-value'>${black_captured}</span>
    </div>
    <div class='score-row'>
      <span class='score-label'>黑方計分:</span>
      <span class='score-value'>${black_stones} + ${black_territory} - 6.5 = ${black_total.toFixed(1)} 目</span>
    </div>
    <hr style="border: none; border-top: 1px solid rgba(0,0,0,0.1); margin: 8px 0;">
    <div class='score-row'>
      <span class='score-label'>白方子數:</span>
      <span class='score-value'>${white_stones}</span>
      <span class='score-label'>地數:</span>
      <span class='score-value'>${white_territory}</span>
      <span class='score-label'>被吃:</span>
      <span class='score-value'>${white_captured}</span>
    </div>
    <div class='score-row'>
      <span class='score-label'>白方計分:</span>
      <span class='score-value'>${white_stones} + ${white_territory} = ${white_total.toFixed(1)} 目</span>
    </div>
    <div class='winner-panel'>${winner}${winner.includes('平局') ? '' : ` (${margin} 目)`}</div>
  `;
        }
        document.getElementById('reset-btn').addEventListener('click', newBoard);

        document.getElementById('undo-btn').addEventListener('click', () => {
            if (moveHistory.length > 0) {
                const lastState = moveHistory.pop();
                board = lastState.board;
                moveNumbers = lastState.moveNumbers;
                turn = lastState.turn;
                captured = lastState.captured;
                moveCounter = lastState.moveCounter;
                drawPracticeBoard();
                calcScore();

                const warningMsg = document.getElementById('warning-message');
                warningMsg.style.display = 'none';
            }
        });
        newBoard();
    </script>
</body>

</html>